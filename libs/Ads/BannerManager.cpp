/* Copyright 2013 David Axmark

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * @file BannerManager.h
 * @author Emma Tresanszki and Bogdan Iusco
 * @date 1 Nov 2011
 *
 * @brief The BannnerManager manages banner events and dispatches
 * them to the target banners.
 */

#include "BannerManager.h"
#include "Banner.h"

namespace Ads
{
	/**
	 * Initialize the singleton variable to NULL.
	 */
	BannerManager* BannerManager::sInstance = NULL;

	/**
	 * Constructor is protected since this is a singleton.
	 * (subclasses can still create instances).
	 */
	BannerManager::BannerManager()
	{
        // Add me as a custom event listener.
        MAUtil::Environment::getEnvironment().addCustomEventListener(this);
	}

	/**
	 * Destructor.
	 */
	BannerManager::~BannerManager()
	{
        // Remove me as a custom event listener.
        MAUtil::Environment::getEnvironment().removeCustomEventListener(this);
	}

	/**
	 * Return the single instance of this class.
	 */
	BannerManager* BannerManager::getInstance()
	{
        if (NULL == BannerManager::sInstance)
        {
            BannerManager::sInstance = new BannerManager();
        }

        return sInstance;
	}

	/**
	 * Destroy the single instance of this class.
	 * Call this method only when the application will exit.
	 */
	void BannerManager::destroyInstance()
	{
        delete BannerManager::sInstance;
	}

	/**
	 * Implementation of CustomEventListener interface.
	 * This method will get called whenever there is a
	 * widget event generated by the system.
	 * @param event The new received event.
	 */
	void BannerManager::customEvent(const MAEvent& event)
	{
        // Check if this is a widget event.
        if (EVENT_TYPE_ADS_BANNER == event.type)
        {
            // Check if the banner exists in the map.
            if (mBannerMap.end() != mBannerMap.find(event.adsData.bannerHandle))
            {
                // Get the banner object that wraps the banner handle.
                Banner* banner = mBannerMap[event.adsData.bannerHandle];

                // Call the banner's event handling method.
                banner->handleBannerEvent(event);
            }
        }
	}

	/**
	 * Add a banner to the map that holds banners.
	 * The banner will receive custom events.
	 * @param banner The banner that needs to be registered.
	 * The ownership of the banner is not passed to this method.
	 */
	void BannerManager::registerBanner(Banner* banner)
	{
		mBannerMap[banner->getHandle()] = banner;
	}

	/**
	 * Remove a banner from the map that holds banners.
	 * The banner will not receive custom events.
	 * @param banner The banner that needs to be unregistered.
	 */
	void BannerManager::unregisterBanner(Banner* banner)
	{
		mBannerMap.erase(banner->getHandle());
	}

} // namespace Ads
