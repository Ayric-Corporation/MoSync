/* Copyright 2013 David Axmark

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef __ANDROID_EVENTQUEUE_H__
#define __ANDROID_EVENTQUEUE_H__

#include "config_platform.h"
#include <helpers/cpp_defs.h>
#include <helpers/CriticalSection.h>
#include <helpers/helpers.h>
#include <helpers/fifo.h>

/**
 * A FIFO Queue implemented using a non-resizable circular buffer.
 * This class is copied from intlibs/helpers/fifo.h and updated
 * with methods for accessing the buffer by index. We need this
 * to be able to update the elements in the queue.
 * Note that methods in this class are NOT protected by a critical
 * section (unlike the origial CircularFifo in fifo.h).
 */
template<class T, int size> class NonProtectedCircularFifo {
public:
	NonProtectedCircularFifo() : mReadPos(0), mWritePos(0) {
	}
	void put(const T& t) {
		mWritePos++;
		if(mWritePos == size)
			mWritePos = 0;
		//prevent overruns; lose the data being put, but not the rest.
		//max count becomes capacity - 1.
		if(mWritePos == mReadPos) {
			//mWritePos--;
			BIG_PHAT_ERROR(ERR_FIFO_OVERRUN);
		} else {
			mBuf[mWritePos] = t;
		}
	}
	const T& get() {
		DEBUG_ASSERT(count() != 0);
		mReadPos++;
		if(mReadPos == size)
			mReadPos = 0;
		const T& t = mBuf[mReadPos];
		return t;
	}
	size_t count() {
		if(mWritePos >= mReadPos)
			return mWritePos - mReadPos;
		else	//(mWritePos < mReadPos)
			return size - mReadPos + mWritePos;
	}
	void clear() {
		mReadPos = mWritePos = 0;
	}
	void putAtIndex(size_t index, const T& t) {
		mBuf[index] = t;
	}
	const T& getAtIndex(size_t index) {
		return mBuf[index];
	}
	size_t getLastIndex() {
		return mWritePos;
	}
private:
	T mBuf[size];
	size_t mReadPos, mWritePos;
};

/**
 * Class that holds events in the MoSync event queue.
 * This class protected the event queue from overflowing
 * in cases when there are very many events generated by
 * the system, such as sensor events. For such events the
 * last event is updated with the most recent event data,
 * no new events are put into the queue in this case, until
 * the current event in the queue has been consumed.
 *
 * This class is curreently used by the Android runtime.
 *
 * @author Mikael Kindborg
 */

#define EVENTQUEUE_SENSORARRAYSIZE 32
#define EVENTQUEUE_POINTERARRAYSIZE 32

// Value used to define NULL for event array elements.
// Note that Zero is a valid index value, therefore
// we use the buffer size  plus one to represent a
// NULL entry.
#define EVENTQUEUE_NULL (EVENT_BUFFER_SIZE + 1)

class EventQueue
{
public:
	EventQueue();
	void put(MAEvent& event);
	const MAEvent& get();
	size_t count();
	void clear();

private:
	// Data structure holding the actual events.
	NonProtectedCircularFifo<MAEvent, EVENT_BUFFER_SIZE> mFifo;

	// Non-NULL if there is an EVENT_TYPE_POINTER_DRAGGED
	// in the queue. The array is used for multi-touch
	// pointers. Values are indexes into the event queue.
	size_t mPointerDraggedEvents[EVENTQUEUE_POINTERARRAYSIZE];

	// Non-NULL if there is an EVENT_TYPE_SENSOR
	// in the queue. The array is used for subtypes
	// of sensor events. Actual values used are 1..6
	// at the time of writing this code. To have more
	// entries than used now makes room for future subtypes.
	// Values are indexes into the event queue.
	size_t mSensorEvents[EVENTQUEUE_SENSORARRAYSIZE];

	// Protects for concurrent calls.
	CRITICAL_SECTION mCriticalSection;
};

#endif
